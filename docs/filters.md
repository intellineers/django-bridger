Filters are based on Django-Filters and can mostly be autogenerated from a simple dictionary when using a `bridger.viewsets.ModelViewSet`. All customized parameters are taken from the attached model and are applied to the filter. When the completely autogenerated filter is not sufficient, a custom `bridger.filters.FilterSet` can be provided to overwrite filters or set custom filters.

### Setup

Below are two examples on how to set up a rudimentary filter, where both examples yield exactly the same result: Two filters for the field `first_field`, one which filters for exact values, and one which filters for similar values (`SQL: LIKE`).

```python
from bridger.filters import DjangoFilterBackend
from bridger.viewsets import ModelViewSet

class XYZModelViewSet(ModelViewSet):
    filter_backends = [DjangoFilterBackend]
    filter_fields = {
        "first_field": ["exact", "icontains"]
    }
```

```python
from bridger.filters import DjangoFilterBackend, FilterSet
from bridger.viewsets import ModelViewSet

class XYZFilterSet(FilterSet):
    class Meta:
        model = XYZ
        fields = {
            "first_field": ["exact", "icontains"]
        }

class XYZModelViewSet(ModelViewSet):
    filter_backends = [DjangoFilterBackend]
    filter_class = XYZFilterSet
```

### Lookup Expressions

!!! warning
    Not all field lookups from [Django](https://docs.djangoproject.com/en/3.0/ref/models/querysets/#field-lookups) are supported yet.

The different lookup expressions that are currently available are:

* `exact`: An exact match against the filtered value (for Text, Number, Dropdown). In SQL `=`
* `icontains`: A loose match against the filtered value (for Text, Number). In SQL `LIKE`
* `gt`: Greater than a value (for Number). In SQL `>`
* `gte`: Greater than or equal to a value (for Number). In SQL `>=`
* `lt`: Less than a value (for Number). In SQL `<`
* `lte`: Less than or equal to a value (for Number). In SQL `<=`

### Custom Filter

As mentioned previously, custom filters are specified in a `bridger.filters.FilterSet`. There are two different reasons for custom filters:

1. Overwrite the filter method behind a filter
2. Specify filters that are not part of a field of the model

When implementing a custom filter, it is really important that this filter is specified the same as the other filters, as a dictionairy.

``` python
from bridger.filters import FilterSet, BooleanFilter

class XYZFilterSet(FilterSet):
    non_field_filter = BooleanFilter(label="Non Field", method="get_non_field_filter")

    def get_non_field_filter(self, queryset, name, value):
        if value:
            return qs.filter(some_field=True)
        return qs

    class Meta:
        model = XYZ
        fields = {
            "non_field_filter": ["exact"]
        }

```